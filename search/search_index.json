{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Computer Science Notes \u00b6 Getting Started \u00b6 In this website, I'll work on my notes about several topics: Parallel and Concurrent Programming with C++ Operating System Maching Learning JavaScript Data Structures and Algorithms How I generate this website \u00b6 I use the static site generator MkDocs and the beautiful theme Material for MkDocs to build this website! All mathematical equations are rendered by KaTeX , and I added overflow-x: auto to prevent overflow issue on small screen devices, so you can scroll horizontally in some math display equations. More Informations \u00b6 For more informations please visit my GitHub site . By Jay Chen on May 14, 2018.","title":"Preface"},{"location":"#computer-science-notes","text":"","title":"Computer Science Notes"},{"location":"#getting-started","text":"In this website, I'll work on my notes about several topics: Parallel and Concurrent Programming with C++ Operating System Maching Learning JavaScript Data Structures and Algorithms","title":"Getting Started"},{"location":"#how-i-generate-this-website","text":"I use the static site generator MkDocs and the beautiful theme Material for MkDocs to build this website! All mathematical equations are rendered by KaTeX , and I added overflow-x: auto to prevent overflow issue on small screen devices, so you can scroll horizontally in some math display equations.","title":"How I generate this website"},{"location":"#more-informations","text":"For more informations please visit my GitHub site . By Jay Chen on May 14, 2018.","title":"More Informations"},{"location":"JavaScript/","text":"JavaScript Data Structures and Algorithms \u00b6 This page contains notes from the course: JavaScript Algorithms and Data Structures Masterclass taught by Colt Steele. All codes are written in ES9 fashion and are formatted by prettier .","title":"Preface"},{"location":"JavaScript/#javascript-data-structures-and-algorithms","text":"This page contains notes from the course: JavaScript Algorithms and Data Structures Masterclass taught by Colt Steele. All codes are written in ES9 fashion and are formatted by prettier .","title":"JavaScript Data Structures and Algorithms"},{"location":"JavaScript/01/divideAndConquer/","text":"Divide and Conquer Pattern \u00b6 This pattern involves dividing a data set into smaller chunks and then repeating a process with a subset of data. This pattern can tremendously decrease time complexity . search(arr, val) \u00b6 Given a sorted array of integers, write a function called search , that accepts a value and returns the index where the value passed to the function is located. If the value is not found, return -1. 1 2 3 search ([ 1 , 2 , 3 , 4 , 5 , 6 ], 4 ); // 3 search ([ 1 , 2 , 3 , 4 , 5 , 6 ], 6 ); // 5 search ([ 1 , 2 , 3 , 4 , 5 , 6 ], 11 ); // -1 Solution 1 (naive) Time: $O(n)$ 1 2 3 4 5 6 const search = ( arr , val ) => { for ( let i = 0 ; i < arr . length ; i ++ ) if ( arr [ i ] === val ) return i ; return - 1 ; }; Solution 2 (binary search) Time: $O(\\log n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const search = ( arr , val ) => { let left = 0 ; let right = arr . length - 1 ; while ( left <= right ) { let mid = Math . floor (( left + right ) / 2 ); let curr = arr [ mid ]; if ( arr [ mid ] < val ) { left = mid + 1 ; } else if ( arr [ mid ] > val ) { right = mid - 1 ; } else { return mid ; } } return - 1 ; };","title":"Divide and Conquer"},{"location":"JavaScript/01/divideAndConquer/#divide-and-conquer-pattern","text":"This pattern involves dividing a data set into smaller chunks and then repeating a process with a subset of data. This pattern can tremendously decrease time complexity .","title":"Divide and Conquer Pattern"},{"location":"JavaScript/01/divideAndConquer/#searcharr-val","text":"Given a sorted array of integers, write a function called search , that accepts a value and returns the index where the value passed to the function is located. If the value is not found, return -1. 1 2 3 search ([ 1 , 2 , 3 , 4 , 5 , 6 ], 4 ); // 3 search ([ 1 , 2 , 3 , 4 , 5 , 6 ], 6 ); // 5 search ([ 1 , 2 , 3 , 4 , 5 , 6 ], 11 ); // -1 Solution 1 (naive) Time: $O(n)$ 1 2 3 4 5 6 const search = ( arr , val ) => { for ( let i = 0 ; i < arr . length ; i ++ ) if ( arr [ i ] === val ) return i ; return - 1 ; }; Solution 2 (binary search) Time: $O(\\log n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const search = ( arr , val ) => { let left = 0 ; let right = arr . length - 1 ; while ( left <= right ) { let mid = Math . floor (( left + right ) / 2 ); let curr = arr [ mid ]; if ( arr [ mid ] < val ) { left = mid + 1 ; } else if ( arr [ mid ] > val ) { right = mid - 1 ; } else { return mid ; } } return - 1 ; };","title":"search(arr, val)"},{"location":"JavaScript/01/frequencyCounters/","text":"Frequency Counters Pattern \u00b6 This pattern uses objects or sets to collect values/frequencies of values. This can often avoid the need for nested loops or $O(n^2)$ operations with arrays/strings. same(arr1, arr2) \u00b6 Write a function called same , which accepts two arrays. The function should return true if every value in the array has it's corresponding value squared in the second array. The frequency of values must be the same. 1 2 3 same ([ 1 , 2 , 3 ], [ 4 , 1 , 9 ]); // true same ([ 1 , 2 , 3 ], [ 1 , 9 ]); // false same ([ 1 , 2 , 1 ], [ 4 , 4 , 1 ]); // false (must be same frequency) Solution 1 (naive) Time: $O(n^2)$ Space: $O(1)$ 1 2 3 4 5 6 7 8 9 10 11 const same = ( arr1 , arr2 ) => { if ( arr1 . length !== arr2 . length ) return false ; for ( let i = 0 ; i < arr1 . length ; i ++ ) { let correctIndex = arr2 . indexOf ( arr1 [ i ] ** 2 ); if ( correctIndex === - 1 ) return false ; arr2 . splice ( correctIndex , 1 ); } return true ; }; Solution 2 (refactor) Time: $O(n)$ Space: $O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const same = ( arr1 , arr2 ) => { if ( arr1 . length !== arr2 . length ) return false ; const freqCount1 = {}; const freqCount2 = {}; for ( let val of arr1 ) freqCount1 [ val ] = ( freqCount1 [ val ] || 0 ) + 1 ; for ( let val of arr2 ) freqCount2 [ val ] = ( freqCount2 [ val ] || 0 ) + 1 ; for ( let key in freqCount1 ) { if ( ! ( key ** 2 in freqCount2 )) return false ; if ( freqCount1 [ key ] !== freqCount2 [ key ** 2 ]) return false ; } return true ; }; validAnagram(arr1, arr2) \u00b6 Given two strings, write a function called validAnagram to determine if the second string is an anagram of the first. An anagram is a word, phrase, or name formed by rearranging the letters of another, such as cinema , formed from iceman . 1 2 3 validAnagram ( '' , '' ); // true validAnagram ( 'aaz' , 'zza' ); // false validAnagram ( 'anagram' , 'nagaram' ); // true Solution Time: $O(n)$ Space: $O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 const validAnagram = ( arr1 , arr2 ) => { if ( arr1 . length !== arr2 . length ) return false ; const freqCount1 = {}; for ( let val of arr1 ) freqCount1 [ val ] = ( freqCount1 [ val ] || 0 ) + 1 ; for ( let val of arr2 ) { if ( ! freqCount1 [ val ]) return false ; freqCount1 [ val ] -- ; } return true ; }; sameFrequency(num1, num2) \u00b6 Write a function called sameFrequency . Given two positive integers, find out if the two numbers have the same frequency of digits. 1 2 3 4 sameFrequency ( 182 , 281 ); // true sameFrequency ( 3589578 , 5879385 ); // true sameFrequency ( 34 , 14 ); // false sameFrequency ( 22 , 222 ); // false Solution Time: $O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const sameFrequency = ( num1 , num2 ) => { strNum1 = num1 . toString (); strNum2 = num2 . toString (); if ( strNum1 . length !== strNum2 . length ) return false ; const freqCount1 = {}; for ( let val of strNum1 ) freqCount1 [ val ] = ( freqCount1 [ val ] || 0 ) + 1 ; for ( let val of strNum2 ) { if ( ! freqCount1 [ val ]) return false ; freqCount1 [ val ] -- ; } return true ; }; areThereDuplicates(...args) \u00b6 Implement a function called, areThereDuplicates which accepts a variable number of arguments, and checks whether there are any duplicates among the arguments passed in. You can solve this using the frequency counter pattern OR the multiple pointers pattern. 1 2 3 areThereDuplicates ( 1 , 2 , 3 ); // false areThereDuplicates ( 1 , 2 , 2 ); // true areThereDuplicates ( 'a' , 'b' , 'c' , 'a' ); // true Solution 1 (frequency counter) Time: $O(n)$ Space: $O(n)$ 1 2 3 4 5 6 7 8 9 10 const areThereDuplicates = (... args ) => { let lookup = {}; for ( let val of args ) { if ( lookup [ val ]) return true ; lookup [ val ] = ( lookup [ val ] || 0 ) + 1 ; } return false ; }; Solution 2 (multiple pointers) Time: $O(n\\log n)$ Space: $O(1)$ 1 2 3 4 5 6 7 8 9 10 11 const areThereDuplicates = (... args ) => { args . sort (); let i = 0 ; for ( let j = 1 ; j < args . length ; i ++ , j ++ ) if ( args [ i ] === args [ j ]) return true ; return false ; }; Solution 3 1 2 3 const areThereDuplicates = () => { return new Set ( arguments ). size !== arguments . length ; };","title":"Frequency Counters"},{"location":"JavaScript/01/frequencyCounters/#frequency-counters-pattern","text":"This pattern uses objects or sets to collect values/frequencies of values. This can often avoid the need for nested loops or $O(n^2)$ operations with arrays/strings.","title":"Frequency Counters Pattern"},{"location":"JavaScript/01/frequencyCounters/#samearr1-arr2","text":"Write a function called same , which accepts two arrays. The function should return true if every value in the array has it's corresponding value squared in the second array. The frequency of values must be the same. 1 2 3 same ([ 1 , 2 , 3 ], [ 4 , 1 , 9 ]); // true same ([ 1 , 2 , 3 ], [ 1 , 9 ]); // false same ([ 1 , 2 , 1 ], [ 4 , 4 , 1 ]); // false (must be same frequency) Solution 1 (naive) Time: $O(n^2)$ Space: $O(1)$ 1 2 3 4 5 6 7 8 9 10 11 const same = ( arr1 , arr2 ) => { if ( arr1 . length !== arr2 . length ) return false ; for ( let i = 0 ; i < arr1 . length ; i ++ ) { let correctIndex = arr2 . indexOf ( arr1 [ i ] ** 2 ); if ( correctIndex === - 1 ) return false ; arr2 . splice ( correctIndex , 1 ); } return true ; }; Solution 2 (refactor) Time: $O(n)$ Space: $O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const same = ( arr1 , arr2 ) => { if ( arr1 . length !== arr2 . length ) return false ; const freqCount1 = {}; const freqCount2 = {}; for ( let val of arr1 ) freqCount1 [ val ] = ( freqCount1 [ val ] || 0 ) + 1 ; for ( let val of arr2 ) freqCount2 [ val ] = ( freqCount2 [ val ] || 0 ) + 1 ; for ( let key in freqCount1 ) { if ( ! ( key ** 2 in freqCount2 )) return false ; if ( freqCount1 [ key ] !== freqCount2 [ key ** 2 ]) return false ; } return true ; };","title":"same(arr1, arr2)"},{"location":"JavaScript/01/frequencyCounters/#validanagramarr1-arr2","text":"Given two strings, write a function called validAnagram to determine if the second string is an anagram of the first. An anagram is a word, phrase, or name formed by rearranging the letters of another, such as cinema , formed from iceman . 1 2 3 validAnagram ( '' , '' ); // true validAnagram ( 'aaz' , 'zza' ); // false validAnagram ( 'anagram' , 'nagaram' ); // true Solution Time: $O(n)$ Space: $O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 const validAnagram = ( arr1 , arr2 ) => { if ( arr1 . length !== arr2 . length ) return false ; const freqCount1 = {}; for ( let val of arr1 ) freqCount1 [ val ] = ( freqCount1 [ val ] || 0 ) + 1 ; for ( let val of arr2 ) { if ( ! freqCount1 [ val ]) return false ; freqCount1 [ val ] -- ; } return true ; };","title":"validAnagram(arr1, arr2)"},{"location":"JavaScript/01/frequencyCounters/#samefrequencynum1-num2","text":"Write a function called sameFrequency . Given two positive integers, find out if the two numbers have the same frequency of digits. 1 2 3 4 sameFrequency ( 182 , 281 ); // true sameFrequency ( 3589578 , 5879385 ); // true sameFrequency ( 34 , 14 ); // false sameFrequency ( 22 , 222 ); // false Solution Time: $O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const sameFrequency = ( num1 , num2 ) => { strNum1 = num1 . toString (); strNum2 = num2 . toString (); if ( strNum1 . length !== strNum2 . length ) return false ; const freqCount1 = {}; for ( let val of strNum1 ) freqCount1 [ val ] = ( freqCount1 [ val ] || 0 ) + 1 ; for ( let val of strNum2 ) { if ( ! freqCount1 [ val ]) return false ; freqCount1 [ val ] -- ; } return true ; };","title":"sameFrequency(num1, num2)"},{"location":"JavaScript/01/frequencyCounters/#arethereduplicatesargs","text":"Implement a function called, areThereDuplicates which accepts a variable number of arguments, and checks whether there are any duplicates among the arguments passed in. You can solve this using the frequency counter pattern OR the multiple pointers pattern. 1 2 3 areThereDuplicates ( 1 , 2 , 3 ); // false areThereDuplicates ( 1 , 2 , 2 ); // true areThereDuplicates ( 'a' , 'b' , 'c' , 'a' ); // true Solution 1 (frequency counter) Time: $O(n)$ Space: $O(n)$ 1 2 3 4 5 6 7 8 9 10 const areThereDuplicates = (... args ) => { let lookup = {}; for ( let val of args ) { if ( lookup [ val ]) return true ; lookup [ val ] = ( lookup [ val ] || 0 ) + 1 ; } return false ; }; Solution 2 (multiple pointers) Time: $O(n\\log n)$ Space: $O(1)$ 1 2 3 4 5 6 7 8 9 10 11 const areThereDuplicates = (... args ) => { args . sort (); let i = 0 ; for ( let j = 1 ; j < args . length ; i ++ , j ++ ) if ( args [ i ] === args [ j ]) return true ; return false ; }; Solution 3 1 2 3 const areThereDuplicates = () => { return new Set ( arguments ). size !== arguments . length ; };","title":"areThereDuplicates(...args)"},{"location":"JavaScript/01/multiplePointers/","text":"Multiple Pointers Pattern \u00b6 Creating pointers or values that correspond to an index or position and move towards the beginning, end or middle based on a certain condition. Very efficient for solving problems with minimal Space as well. sumZero(arr) \u00b6 Write a function called sumZero which accepts a sorted array of integers. The function should find the first pair where the sum is 0. Return an array that includes both values that sum to zero or undefined if a pair does not exist. 1 2 3 sumZero ([ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 ]); // [-3, 3] sumZero ([ - 2 , 0 , 1 , 3 ]); // undefined sumZero ([ 1 , 2 , 3 ]); // undefined Solution 1 (naive) Time: $O(n^2)$ Space: $O(1)$ 1 2 3 4 5 6 const sumZero = arr => { for ( let i = 0 ; i < arr . length ; i ++ ) for ( let j = i + 1 ; j < arr . length ; j ++ ) if ( arr [ i ] + arr [ j ] === 0 ) return [ arr [ i ], arr [ j ]]; }; Solution 2 (refactor): Time: $O(n)$ Space: $O(1)$ 1 2 3 4 5 6 7 8 9 10 11 12 const sumZero = arr => { let left = 0 ; let right = arr . length - 1 ; while ( left < right ) { let sum = arr [ left ] + arr [ right ]; if ( sum === 0 ) return [ arr [ left ], arr [ right ]]; else if ( sum < 0 ) left ++ ; else right -- ; } }; countUniqueValues(arr) \u00b6 Implement a function called countUniqueValues , which accepts a sorted array, and counts the unique values in the array. There can be negative numbers in the array, but it will always be sorted. 1 2 3 countUniqueValues ([ 1 , 1 , 1 , 1 , 1 , 2 ]); // 2 countUniqueValues ([ - 2 , - 1 , - 1 , 0 , 1 ]); // 4 countUniqueValues ([]); // 0 Solution: Time: $O(n)$ Space: $O(1)$ 1 2 3 4 5 6 7 8 9 10 const countUniqueValues = arr => { if ( arr . length === 0 ) return 0 ; let i = 0 ; for ( let j = 1 ; j < arr . length ; j ++ ) if ( arr [ i ] !== arr [ j ]) arr [ ++ i ] = arr [ j ]; return i + 1 ; }; averagePair(arr, val) \u00b6 Write a function called averagePair . Given a sorted array of integers and a target average, determine if there is a pair of values in the array where the average of the pair equals the target average. There may be more than one pair that matches the average target. 1 2 3 4 averagePair ([ 1 , 2 , 3 ], 2.5 ); // true averagePair ([ 1 , 3 , 3 , 5 , 6 , 7 , 10 , 12 , 19 ], 8 ); // true averagePair ([ - 1 , 0 , 3 , 4 , 5 , 6 ], 4.1 ); // false averagePair ([], 4 ); // false Solution: Time: $O(n)$ Space: $O(1)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const averagePair = ( arr , num ) => { let left = 0 ; let right = arr . length - 1 ; while ( left < right ) { let average = ( arr [ left ] + arr [ right ]) / 2 ; if ( average === num ) return true ; else if ( average < num ) left ++ ; else right -- ; } return false ; }; isSubsequence(str1, str2) \u00b6 Write a function called isSubsequence which takes in two strings and checks whether the characters in the first string form a subsequence of the characters in the second string. In other words, the function should check whether the characters in the first string appear somewhere in the second string, without their order changing . 1 2 3 isSubsequence ( 'hello' , 'hello world' ); // true isSubsequence ( 'sing' , 'sting' ); // true isSubsequence ( 'abc' , 'acb' ); // false (order matters) Solution 1 (iterative): Time: $O(n + m)$ Space: $O(1)$ 1 2 3 4 5 6 7 8 9 10 11 const isSubsequence = ( str1 , str2 ) => { if ( ! str1 ) return true ; let i = 0 ; for ( let j = 0 ; j < str2 . length ; j ++ ) { if ( i == str1 . length - 1 ) return true ; if ( str1 [ i ] === str2 [ j ]) i ++ ; } return false ; }; Solution 2 (recursive but not $O(1)$ space): 1 2 3 4 5 6 const isSubsequence = ( str1 , str2 ) => { if ( str1 . length === 0 ) return true ; if ( str2 . length === 0 ) return false ; if ( str2 [ 0 ] === str1 [ 0 ]) return isSubsequence ( str1 . slice ( 1 ), str2 . slice ( 1 )); return isSubsequence ( str1 , str2 . slice ( 1 )); };","title":"Multiple Pointers"},{"location":"JavaScript/01/multiplePointers/#multiple-pointers-pattern","text":"Creating pointers or values that correspond to an index or position and move towards the beginning, end or middle based on a certain condition. Very efficient for solving problems with minimal Space as well.","title":"Multiple Pointers Pattern"},{"location":"JavaScript/01/multiplePointers/#sumzeroarr","text":"Write a function called sumZero which accepts a sorted array of integers. The function should find the first pair where the sum is 0. Return an array that includes both values that sum to zero or undefined if a pair does not exist. 1 2 3 sumZero ([ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 ]); // [-3, 3] sumZero ([ - 2 , 0 , 1 , 3 ]); // undefined sumZero ([ 1 , 2 , 3 ]); // undefined Solution 1 (naive) Time: $O(n^2)$ Space: $O(1)$ 1 2 3 4 5 6 const sumZero = arr => { for ( let i = 0 ; i < arr . length ; i ++ ) for ( let j = i + 1 ; j < arr . length ; j ++ ) if ( arr [ i ] + arr [ j ] === 0 ) return [ arr [ i ], arr [ j ]]; }; Solution 2 (refactor): Time: $O(n)$ Space: $O(1)$ 1 2 3 4 5 6 7 8 9 10 11 12 const sumZero = arr => { let left = 0 ; let right = arr . length - 1 ; while ( left < right ) { let sum = arr [ left ] + arr [ right ]; if ( sum === 0 ) return [ arr [ left ], arr [ right ]]; else if ( sum < 0 ) left ++ ; else right -- ; } };","title":"sumZero(arr)"},{"location":"JavaScript/01/multiplePointers/#countuniquevaluesarr","text":"Implement a function called countUniqueValues , which accepts a sorted array, and counts the unique values in the array. There can be negative numbers in the array, but it will always be sorted. 1 2 3 countUniqueValues ([ 1 , 1 , 1 , 1 , 1 , 2 ]); // 2 countUniqueValues ([ - 2 , - 1 , - 1 , 0 , 1 ]); // 4 countUniqueValues ([]); // 0 Solution: Time: $O(n)$ Space: $O(1)$ 1 2 3 4 5 6 7 8 9 10 const countUniqueValues = arr => { if ( arr . length === 0 ) return 0 ; let i = 0 ; for ( let j = 1 ; j < arr . length ; j ++ ) if ( arr [ i ] !== arr [ j ]) arr [ ++ i ] = arr [ j ]; return i + 1 ; };","title":"countUniqueValues(arr)"},{"location":"JavaScript/01/multiplePointers/#averagepairarr-val","text":"Write a function called averagePair . Given a sorted array of integers and a target average, determine if there is a pair of values in the array where the average of the pair equals the target average. There may be more than one pair that matches the average target. 1 2 3 4 averagePair ([ 1 , 2 , 3 ], 2.5 ); // true averagePair ([ 1 , 3 , 3 , 5 , 6 , 7 , 10 , 12 , 19 ], 8 ); // true averagePair ([ - 1 , 0 , 3 , 4 , 5 , 6 ], 4.1 ); // false averagePair ([], 4 ); // false Solution: Time: $O(n)$ Space: $O(1)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const averagePair = ( arr , num ) => { let left = 0 ; let right = arr . length - 1 ; while ( left < right ) { let average = ( arr [ left ] + arr [ right ]) / 2 ; if ( average === num ) return true ; else if ( average < num ) left ++ ; else right -- ; } return false ; };","title":"averagePair(arr, val)"},{"location":"JavaScript/01/multiplePointers/#issubsequencestr1-str2","text":"Write a function called isSubsequence which takes in two strings and checks whether the characters in the first string form a subsequence of the characters in the second string. In other words, the function should check whether the characters in the first string appear somewhere in the second string, without their order changing . 1 2 3 isSubsequence ( 'hello' , 'hello world' ); // true isSubsequence ( 'sing' , 'sting' ); // true isSubsequence ( 'abc' , 'acb' ); // false (order matters) Solution 1 (iterative): Time: $O(n + m)$ Space: $O(1)$ 1 2 3 4 5 6 7 8 9 10 11 const isSubsequence = ( str1 , str2 ) => { if ( ! str1 ) return true ; let i = 0 ; for ( let j = 0 ; j < str2 . length ; j ++ ) { if ( i == str1 . length - 1 ) return true ; if ( str1 [ i ] === str2 [ j ]) i ++ ; } return false ; }; Solution 2 (recursive but not $O(1)$ space): 1 2 3 4 5 6 const isSubsequence = ( str1 , str2 ) => { if ( str1 . length === 0 ) return true ; if ( str2 . length === 0 ) return false ; if ( str2 [ 0 ] === str1 [ 0 ]) return isSubsequence ( str1 . slice ( 1 ), str2 . slice ( 1 )); return isSubsequence ( str1 , str2 . slice ( 1 )); };","title":"isSubsequence(str1, str2)"},{"location":"JavaScript/01/slidingWindow/","text":"Sliding Window Pattern \u00b6 This pattern involves creating a window which can either be an array or number from one position to another. Depending on a certain condition, the window either increases or closes (and a new window is created). Very useful for keeping track of a subset of data in an array/string etc. maxSubarraySum(arr, n) \u00b6 Write a function called maxSubarraySum which accepts an array of integers and a number called n . The function should calculate the maximum sum of n consecutive elements in the array. 1 2 3 4 maxSubarraySum ([ 1 , 2 , 5 , 2 , 8 , 1 , 5 ], 2 ); // 10 maxSubarraySum ([ 1 , 2 , 5 , 2 , 8 , 1 , 5 ], 4 ); // 17 maxSubarraySum ([ 4 , 2 , 1 , 6 ], 1 ); // 6 maxSubarraySum ([], 4 ); // null Solution 1 (naive): Time: $O(n^2)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const maxSubarraySum = ( arr , n ) => { if ( n > arr . length ) return null ; let ret = - Infinity ; for ( let i = 0 ; i < arr . length - n + 1 ; i ++ ) { let temp = 0 ; for ( let j = 0 ; j < n ; j ++ ) temp += arr [ i + j ]; ret = Math . max ( ret , temp ); } return ret ; }; Solution 2 (refactor): Time: $O(n)$ Space: $O(1)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const maxSubarraySum = ( arr , n ) => { if ( arr . length < n ) return null ; let ret = 0 ; let temp = 0 ; for ( let i = 0 ; i < n ; i ++ ) ret += arr [ i ]; temp = ret ; for ( let i = n ; i < arr . length ; i ++ ) { temp = temp - arr [ i - n ] + arr [ i ]; ret = Math . max ( ret , temp ); } return ret ; }; minSubArrayLen(arr, num) \u00b6 Write a function called minSubArrayLen which accepts two parameters - an array of positive integers and a positive integer. This function should return the minimal length of a contiguous subarray of which the sum is greater than or equal to the integer passed to the function. If there isn\u2019t one, return 0 instead. 1 2 3 minSubArrayLen ([ 2 , 3 , 1 , 2 , 4 , 3 ], 7 ); // 2 -> because [4, 3] is the smallest subarray minSubArrayLen ([ 2 , 1 , 6 , 5 , 4 ], 9 ); // 2 -> because [5, 4] is the smallest subarray minSubArrayLen ([ 3 , 1 , 62 , 19 ], 52 ); // 1 -> because [62] is greater than 52 Solution Time: $O(n)$ Space: $O(1)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const minSubArrayLen = ( arr , num ) => { let i = 0 ; // start let j = 0 ; // end let sum = 0 ; let ret = Infinity ; while ( i < arr . length ) { if ( sum < num && j < arr . length ) { sum += arr [ j ]; j ++ ; } else if ( sum >= num ) { ret = Math . min ( ret , j - i ); sum -= arr [ i ]; i ++ ; } else { break ; } } return ret === Infinity ? 0 : ret ; }; findLongestSubstring(str) \u00b6 Write a function called findLongestSubstring , which accepts a string and returns the length of the longest substring with all distinct characters. 1 2 3 4 findLongestSubstring ( '' ); // 0 findLongestSubstring ( 'rithmschool' ); // 7 findLongestSubstring ( 'thecatinthehat' ); // 7 findLongestSubstring ( 'bbbbbb' ); // 1 Solution: Time: $O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const findLongestSubstring = str => { let ret = 0 ; let seen = {}; let i = 0 ; for ( let j = 0 ; j < str . length ; j ++ ) { let char = str [ j ]; if ( seen [ char ]) i = Math . max ( i , seen [ char ]); ret = Math . max ( ret , j - i + 1 ); seen [ char ] = j + 1 ; } return ret ; };","title":"Sliding Window"},{"location":"JavaScript/01/slidingWindow/#sliding-window-pattern","text":"This pattern involves creating a window which can either be an array or number from one position to another. Depending on a certain condition, the window either increases or closes (and a new window is created). Very useful for keeping track of a subset of data in an array/string etc.","title":"Sliding Window Pattern"},{"location":"JavaScript/01/slidingWindow/#maxsubarraysumarr-n","text":"Write a function called maxSubarraySum which accepts an array of integers and a number called n . The function should calculate the maximum sum of n consecutive elements in the array. 1 2 3 4 maxSubarraySum ([ 1 , 2 , 5 , 2 , 8 , 1 , 5 ], 2 ); // 10 maxSubarraySum ([ 1 , 2 , 5 , 2 , 8 , 1 , 5 ], 4 ); // 17 maxSubarraySum ([ 4 , 2 , 1 , 6 ], 1 ); // 6 maxSubarraySum ([], 4 ); // null Solution 1 (naive): Time: $O(n^2)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const maxSubarraySum = ( arr , n ) => { if ( n > arr . length ) return null ; let ret = - Infinity ; for ( let i = 0 ; i < arr . length - n + 1 ; i ++ ) { let temp = 0 ; for ( let j = 0 ; j < n ; j ++ ) temp += arr [ i + j ]; ret = Math . max ( ret , temp ); } return ret ; }; Solution 2 (refactor): Time: $O(n)$ Space: $O(1)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const maxSubarraySum = ( arr , n ) => { if ( arr . length < n ) return null ; let ret = 0 ; let temp = 0 ; for ( let i = 0 ; i < n ; i ++ ) ret += arr [ i ]; temp = ret ; for ( let i = n ; i < arr . length ; i ++ ) { temp = temp - arr [ i - n ] + arr [ i ]; ret = Math . max ( ret , temp ); } return ret ; };","title":"maxSubarraySum(arr, n)"},{"location":"JavaScript/01/slidingWindow/#minsubarraylenarr-num","text":"Write a function called minSubArrayLen which accepts two parameters - an array of positive integers and a positive integer. This function should return the minimal length of a contiguous subarray of which the sum is greater than or equal to the integer passed to the function. If there isn\u2019t one, return 0 instead. 1 2 3 minSubArrayLen ([ 2 , 3 , 1 , 2 , 4 , 3 ], 7 ); // 2 -> because [4, 3] is the smallest subarray minSubArrayLen ([ 2 , 1 , 6 , 5 , 4 ], 9 ); // 2 -> because [5, 4] is the smallest subarray minSubArrayLen ([ 3 , 1 , 62 , 19 ], 52 ); // 1 -> because [62] is greater than 52 Solution Time: $O(n)$ Space: $O(1)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const minSubArrayLen = ( arr , num ) => { let i = 0 ; // start let j = 0 ; // end let sum = 0 ; let ret = Infinity ; while ( i < arr . length ) { if ( sum < num && j < arr . length ) { sum += arr [ j ]; j ++ ; } else if ( sum >= num ) { ret = Math . min ( ret , j - i ); sum -= arr [ i ]; i ++ ; } else { break ; } } return ret === Infinity ? 0 : ret ; };","title":"minSubArrayLen(arr, num)"},{"location":"JavaScript/01/slidingWindow/#findlongestsubstringstr","text":"Write a function called findLongestSubstring , which accepts a string and returns the length of the longest substring with all distinct characters. 1 2 3 4 findLongestSubstring ( '' ); // 0 findLongestSubstring ( 'rithmschool' ); // 7 findLongestSubstring ( 'thecatinthehat' ); // 7 findLongestSubstring ( 'bbbbbb' ); // 1 Solution: Time: $O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const findLongestSubstring = str => { let ret = 0 ; let seen = {}; let i = 0 ; for ( let j = 0 ; j < str . length ; j ++ ) { let char = str [ j ]; if ( seen [ char ]) i = Math . max ( i , seen [ char ]); ret = Math . max ( ret , j - i + 1 ); seen [ char ] = j + 1 ; } return ret ; };","title":"findLongestSubstring(str)"},{"location":"JavaScript/02/recursionEasy/","text":"Recursion Problem Set (easy) \u00b6 power(n, x) \u00b6 Write a function called power which accepts a base and an exponent. The function should return the power of the base to the exponent. This function should mimic the functionality of Math.pow() - do not worry about negative bases and exponents. 1 2 3 4 5 6 const power = ( n , x ) => { if ( x == 0 ) return 1 ; if ( x == 1 ) return n ; let t = power ( n , Math . floor ( x / 2 )); return t * t * power ( n , x % 2 ); }; factorial(n) \u00b6 Write a function factorial which accepts a number and returns the factorial of that number. A factorial is the product of an integer and all the integers below it; e.g., factorial four (4!) is equal to 24, because 4 * 3 * 2 * 1 equals 24. factorial zero (0!) is always 1. 1 2 3 4 const factorial = n => { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ); }; productOfArray(arr) \u00b6 Write a function called productOfArray which takes in an array of numbers and returns the product of them all. 1 2 3 4 const productOfArray = arr => { if ( arr . length == 0 ) return 1 ; return arr [ 0 ] * productOfArray ( arr . splice ( 1 )); }; recursiveRange(num) \u00b6 Write a function called recursiveRange which accepts a number and adds up all the numbers from 0 to the number passed to the function. 1 2 3 4 const recursiveRange = num => { if ( num == 0 ) return 0 ; return num + recursiveRange ( num - 1 ); }; fib(num) \u00b6 Write a recursive function called fib which accepts a number and returns the nth number in the Fibonacci sequence. Recall that the Fibonacci sequence is the sequence of whole numbers 1, 1, 2, 3, 5, 8, which starts with 1 and 1, and where every number thereafter is equal to the sum of the previous two numbers. 1 2 3 4 const fib = num => { if ( num == 1 || num == 2 ) return 1 ; return fib ( num - 1 ) + fib ( num - 2 ); };","title":"Recursion Problem Set (easy)"},{"location":"JavaScript/02/recursionEasy/#recursion-problem-set-easy","text":"","title":"Recursion Problem Set (easy)"},{"location":"JavaScript/02/recursionEasy/#powern-x","text":"Write a function called power which accepts a base and an exponent. The function should return the power of the base to the exponent. This function should mimic the functionality of Math.pow() - do not worry about negative bases and exponents. 1 2 3 4 5 6 const power = ( n , x ) => { if ( x == 0 ) return 1 ; if ( x == 1 ) return n ; let t = power ( n , Math . floor ( x / 2 )); return t * t * power ( n , x % 2 ); };","title":"power(n, x)"},{"location":"JavaScript/02/recursionEasy/#factorialn","text":"Write a function factorial which accepts a number and returns the factorial of that number. A factorial is the product of an integer and all the integers below it; e.g., factorial four (4!) is equal to 24, because 4 * 3 * 2 * 1 equals 24. factorial zero (0!) is always 1. 1 2 3 4 const factorial = n => { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ); };","title":"factorial(n)"},{"location":"JavaScript/02/recursionEasy/#productofarrayarr","text":"Write a function called productOfArray which takes in an array of numbers and returns the product of them all. 1 2 3 4 const productOfArray = arr => { if ( arr . length == 0 ) return 1 ; return arr [ 0 ] * productOfArray ( arr . splice ( 1 )); };","title":"productOfArray(arr)"},{"location":"JavaScript/02/recursionEasy/#recursiverangenum","text":"Write a function called recursiveRange which accepts a number and adds up all the numbers from 0 to the number passed to the function. 1 2 3 4 const recursiveRange = num => { if ( num == 0 ) return 0 ; return num + recursiveRange ( num - 1 ); };","title":"recursiveRange(num)"},{"location":"JavaScript/02/recursionEasy/#fibnum","text":"Write a recursive function called fib which accepts a number and returns the nth number in the Fibonacci sequence. Recall that the Fibonacci sequence is the sequence of whole numbers 1, 1, 2, 3, 5, 8, which starts with 1 and 1, and where every number thereafter is equal to the sum of the previous two numbers. 1 2 3 4 const fib = num => { if ( num == 1 || num == 2 ) return 1 ; return fib ( num - 1 ) + fib ( num - 2 ); };","title":"fib(num)"},{"location":"JavaScript/02/recursionHard/","text":"Recursion Problem Set (hard) \u00b6 reverse(str) \u00b6 Write a recursive function called reverse which accepts a string and returns a new string in reverse. 1 2 reverse ( 'awesome' ); // 'emosewa' reverse ( 'rithmschool' ); // 'loohcsmhtir' Solution: 1 2 3 4 const reverse = str => { if ( str . length <= 1 ) return str ; return reverse ( str . slice ( 1 )) + str [ 0 ]; }; isPalindrome(str) \u00b6 Write a recursive function called isPalindrome which returns true if the string passed to it is a palindrome (reads the same forward and backward). Otherwise it returns false. 1 2 3 4 5 isPalindrome ( 'awesome' ); // false isPalindrome ( 'foobar' ); // false isPalindrome ( 'tacocat' ); // true isPalindrome ( 'amanaplanacanalpanama' ); // true isPalindrome ( 'amanaplanacanalpandemonium' ); // false Solution: 1 2 3 4 5 6 const isPalindrome = str => { if ( str . length == 1 ) return true ; if ( str . length == 2 ) return str [ 0 ] == str [ 1 ]; if ( str [ 0 ] === str . slice ( - 1 )) return isPalindrome ( str . slice ( 1 , - 1 )); return false ; }; someRecursive(arr, callback) \u00b6 Write a recursive function called someRecursive which accepts an array and a callback. The function returns true if a single value in the array returns true when passed to the callback. Otherwise it returns false. 1 2 3 4 5 const isOdd = val => val % 2 !== 0 ; someRecursive ([ 1 , 2 , 3 , 4 ], isOdd ); // true someRecursive ([ 4 , 6 , 8 , 9 ], isOdd ); // true someRecursive ([ 4 , 6 , 8 ], isOdd ); // false someRecursive ([ 4 , 6 , 8 ], val => val > 10 ); // false Solution: 1 2 3 4 5 const someRecursive = ( arr , callback ) => { if ( callback ( arr [ 0 ])) return true ; if ( arr . length == 1 ) return callback ( arr [ 0 ]); return someRecursive ( arr . slice ( 1 ), callback ); }; flatten \u00b6 Write a recursive function called flatten which accepts an array of arrays and returns a new array with all values flattened. 1 2 3 4 flatten ([ 1 , 2 , 3 , [ 4 , 5 ]]); // [1, 2, 3, 4, 5] flatten ([ 1 , [ 2 , [ 3 , 4 ], [[ 5 ]]]]); // [1, 2, 3, 4, 5] flatten ([[ 1 ], [ 2 ], [ 3 ]]); // [1, 2, 3] flatten ([[[[ 1 ], [[[ 2 ]]], [[[[[[[ 3 ]]]]]]]]]]); // [1, 2, 3] Solution: 1 2 3 4 5 6 7 8 9 10 11 const flatten = oldArr => { let newArr = []; for ( let i = 0 ; i < oldArr . length ; i ++ ) { if ( Array . isArray ( oldArr [ i ])) { newArr = newArr . concat ( flatten ( oldArr [ i ])); } else { newArr = [... newArr , oldArr [ i ]]; } } return newArr ; }; capitalizeFirst \u00b6 Write a recursive function called capitalizeFirst . Given an array of strings, capitalize the first letter of each string in the array. 1 capitalizeFirst ([ 'car' , 'taco' , 'banana' ]); // ['Car', 'Taco', 'Banana'] Solution: 1","title":"Recursion Problem Set (hard)"},{"location":"JavaScript/02/recursionHard/#recursion-problem-set-hard","text":"","title":"Recursion Problem Set (hard)"},{"location":"JavaScript/02/recursionHard/#reversestr","text":"Write a recursive function called reverse which accepts a string and returns a new string in reverse. 1 2 reverse ( 'awesome' ); // 'emosewa' reverse ( 'rithmschool' ); // 'loohcsmhtir' Solution: 1 2 3 4 const reverse = str => { if ( str . length <= 1 ) return str ; return reverse ( str . slice ( 1 )) + str [ 0 ]; };","title":"reverse(str)"},{"location":"JavaScript/02/recursionHard/#ispalindromestr","text":"Write a recursive function called isPalindrome which returns true if the string passed to it is a palindrome (reads the same forward and backward). Otherwise it returns false. 1 2 3 4 5 isPalindrome ( 'awesome' ); // false isPalindrome ( 'foobar' ); // false isPalindrome ( 'tacocat' ); // true isPalindrome ( 'amanaplanacanalpanama' ); // true isPalindrome ( 'amanaplanacanalpandemonium' ); // false Solution: 1 2 3 4 5 6 const isPalindrome = str => { if ( str . length == 1 ) return true ; if ( str . length == 2 ) return str [ 0 ] == str [ 1 ]; if ( str [ 0 ] === str . slice ( - 1 )) return isPalindrome ( str . slice ( 1 , - 1 )); return false ; };","title":"isPalindrome(str)"},{"location":"JavaScript/02/recursionHard/#somerecursivearr-callback","text":"Write a recursive function called someRecursive which accepts an array and a callback. The function returns true if a single value in the array returns true when passed to the callback. Otherwise it returns false. 1 2 3 4 5 const isOdd = val => val % 2 !== 0 ; someRecursive ([ 1 , 2 , 3 , 4 ], isOdd ); // true someRecursive ([ 4 , 6 , 8 , 9 ], isOdd ); // true someRecursive ([ 4 , 6 , 8 ], isOdd ); // false someRecursive ([ 4 , 6 , 8 ], val => val > 10 ); // false Solution: 1 2 3 4 5 const someRecursive = ( arr , callback ) => { if ( callback ( arr [ 0 ])) return true ; if ( arr . length == 1 ) return callback ( arr [ 0 ]); return someRecursive ( arr . slice ( 1 ), callback ); };","title":"someRecursive(arr, callback)"},{"location":"JavaScript/02/recursionHard/#flatten","text":"Write a recursive function called flatten which accepts an array of arrays and returns a new array with all values flattened. 1 2 3 4 flatten ([ 1 , 2 , 3 , [ 4 , 5 ]]); // [1, 2, 3, 4, 5] flatten ([ 1 , [ 2 , [ 3 , 4 ], [[ 5 ]]]]); // [1, 2, 3, 4, 5] flatten ([[ 1 ], [ 2 ], [ 3 ]]); // [1, 2, 3] flatten ([[[[ 1 ], [[[ 2 ]]], [[[[[[[ 3 ]]]]]]]]]]); // [1, 2, 3] Solution: 1 2 3 4 5 6 7 8 9 10 11 const flatten = oldArr => { let newArr = []; for ( let i = 0 ; i < oldArr . length ; i ++ ) { if ( Array . isArray ( oldArr [ i ])) { newArr = newArr . concat ( flatten ( oldArr [ i ])); } else { newArr = [... newArr , oldArr [ i ]]; } } return newArr ; };","title":"flatten"},{"location":"JavaScript/02/recursionHard/#capitalizefirst","text":"Write a recursive function called capitalizeFirst . Given an array of strings, capitalize the first letter of each string in the array. 1 capitalizeFirst ([ 'car' , 'taco' , 'banana' ]); // ['Car', 'Taco', 'Banana'] Solution: 1","title":"capitalizeFirst"},{"location":"JavaScript/03/bubbleSort/","text":"Bubble Sort \u00b6 swap(arr, i, j) \u00b6 1 2 3 const swap = ( arr , i , j ) => { [ arr [ i ], arr [ j ]] = [ arr [ j ], arr [ i ]]; }; bubbleSort(arr) \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const bubbleSort = arr => { for ( let i = arr . length - 1 ; i > 0 ; i -- ) { let noSwaps = true ; for ( let j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ]) { swap ( arr , j , j + 1 ); noSwaps = false ; } } if ( noSwaps ) break ; } return arr ; };","title":"Bubble Sort"},{"location":"JavaScript/03/bubbleSort/#bubble-sort","text":"","title":"Bubble Sort"},{"location":"JavaScript/03/bubbleSort/#swaparr-i-j","text":"1 2 3 const swap = ( arr , i , j ) => { [ arr [ i ], arr [ j ]] = [ arr [ j ], arr [ i ]]; };","title":"swap(arr, i, j)"},{"location":"JavaScript/03/bubbleSort/#bubblesortarr","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const bubbleSort = arr => { for ( let i = arr . length - 1 ; i > 0 ; i -- ) { let noSwaps = true ; for ( let j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ]) { swap ( arr , j , j + 1 ); noSwaps = false ; } } if ( noSwaps ) break ; } return arr ; };","title":"bubbleSort(arr)"},{"location":"JavaScript/03/insertionSort/","text":"Insertion Sort \u00b6 insertionSort(arr) \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 const insertionSort = arr => { for ( let i = 1 ; i < arr . length ; i ++ ) { let curr = arr [ i ]; for ( var j = i - 1 ; j >= 0 && arr [ j ] > curr ; j -- ) arr [ j + 1 ] = arr [ j ]; arr [ j + 1 ] = curr ; } return arr ; };","title":"Insertion Sort"},{"location":"JavaScript/03/insertionSort/#insertion-sort","text":"","title":"Insertion Sort"},{"location":"JavaScript/03/insertionSort/#insertionsortarr","text":"1 2 3 4 5 6 7 8 9 10 11 12 const insertionSort = arr => { for ( let i = 1 ; i < arr . length ; i ++ ) { let curr = arr [ i ]; for ( var j = i - 1 ; j >= 0 && arr [ j ] > curr ; j -- ) arr [ j + 1 ] = arr [ j ]; arr [ j + 1 ] = curr ; } return arr ; };","title":"insertionSort(arr)"},{"location":"JavaScript/03/mergeSort/","text":"Merge Sort \u00b6 merge(arr1, arr2) \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const merge = ( arr1 , arr2 ) => { let ret = []; let i = 0 ; let j = 0 ; while ( i < arr1 . length && j < arr2 . length ) { if ( arr1 [ i ] < arr2 [ j ]) ret . push ( arr1 [ i ++ ]); else ret . push ( arr2 [ j ++ ]); } while ( i < arr1 . length ) ret . push ( arr1 [ i ++ ]); while ( j < arr2 . length ) ret . push ( arr2 [ j ++ ]); return ret ; }; mergeSort(arr) \u00b6 1 2 3 4 5 6 7 8 9 const mergeSort = arr => { if ( arr . length <= 1 ) return arr ; let mid = Math . floor ( arr . length / 2 ); let left = mergeSort ( arr . slice ( 0 , mid )); let right = mergeSort ( arr . slice ( mid )); return merge ( left , right ); };","title":"Merge Sort"},{"location":"JavaScript/03/mergeSort/#merge-sort","text":"","title":"Merge Sort"},{"location":"JavaScript/03/mergeSort/#mergearr1-arr2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const merge = ( arr1 , arr2 ) => { let ret = []; let i = 0 ; let j = 0 ; while ( i < arr1 . length && j < arr2 . length ) { if ( arr1 [ i ] < arr2 [ j ]) ret . push ( arr1 [ i ++ ]); else ret . push ( arr2 [ j ++ ]); } while ( i < arr1 . length ) ret . push ( arr1 [ i ++ ]); while ( j < arr2 . length ) ret . push ( arr2 [ j ++ ]); return ret ; };","title":"merge(arr1, arr2)"},{"location":"JavaScript/03/mergeSort/#mergesortarr","text":"1 2 3 4 5 6 7 8 9 const mergeSort = arr => { if ( arr . length <= 1 ) return arr ; let mid = Math . floor ( arr . length / 2 ); let left = mergeSort ( arr . slice ( 0 , mid )); let right = mergeSort ( arr . slice ( mid )); return merge ( left , right ); };","title":"mergeSort(arr)"},{"location":"JavaScript/03/quickSort/","text":"Quick Sort \u00b6 pivot(arr, left = 0, right = arr.length - 1) \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const pivot = ( arr , left , right ) => { const swap = ( arr , i , j ) => { [ arr [ i ], arr [ j ]] = [ arr [ j ], arr [ i ]]; }; let pivot = arr [ left ]; let swapIndex = left ; for ( let i = left + 1 ; i <= right ; i ++ ) if ( pivot > arr [ i ]) swap ( arr , ++ swapIndex , i ); swap ( arr , left , swapIndex ); return swapIndex ; }; quickSort(arr) \u00b6 1 2 3 4 5 6 7 8 9 const quickSort = ( arr , left = 0 , right = arr . length - 1 ) => { if ( left < right ) { let pivotIndex = pivot ( arr , left , right ); quickSort ( arr , left , pivotIndex - 1 ); quickSort ( arr , pivotIndex + 1 , right ); } return arr ; };","title":"Quick Sort"},{"location":"JavaScript/03/quickSort/#quick-sort","text":"","title":"Quick Sort"},{"location":"JavaScript/03/quickSort/#pivotarr-left-0-right-arrlength-1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const pivot = ( arr , left , right ) => { const swap = ( arr , i , j ) => { [ arr [ i ], arr [ j ]] = [ arr [ j ], arr [ i ]]; }; let pivot = arr [ left ]; let swapIndex = left ; for ( let i = left + 1 ; i <= right ; i ++ ) if ( pivot > arr [ i ]) swap ( arr , ++ swapIndex , i ); swap ( arr , left , swapIndex ); return swapIndex ; };","title":"pivot(arr, left = 0, right = arr.length - 1)"},{"location":"JavaScript/03/quickSort/#quicksortarr","text":"1 2 3 4 5 6 7 8 9 const quickSort = ( arr , left = 0 , right = arr . length - 1 ) => { if ( left < right ) { let pivotIndex = pivot ( arr , left , right ); quickSort ( arr , left , pivotIndex - 1 ); quickSort ( arr , pivotIndex + 1 , right ); } return arr ; };","title":"quickSort(arr)"},{"location":"JavaScript/03/selectionSort/","text":"Selection Sort \u00b6 swap(arr, i, j) \u00b6 1 2 3 const swap = ( arr , i , j ) => { [ arr [ i ], arr [ j ]] = [ arr [ j ], arr [ i ]]; }; selectionSort(arr) \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 const selectionSort = arr => { for ( let i = 0 ; i < arr . length ; i ++ ) { let smallest = i ; for ( let j = i + 1 ; j < arr . length ; j ++ ) { if ( arr [ smallest ] > arr [ j ]) { smallest = j ; } } if ( i !== smallest ) swap ( arr , i , smallest ); } return arr ; };","title":"Selection Sort"},{"location":"JavaScript/03/selectionSort/#selection-sort","text":"","title":"Selection Sort"},{"location":"JavaScript/03/selectionSort/#swaparr-i-j","text":"1 2 3 const swap = ( arr , i , j ) => { [ arr [ i ], arr [ j ]] = [ arr [ j ], arr [ i ]]; };","title":"swap(arr, i, j)"},{"location":"JavaScript/03/selectionSort/#selectionsortarr","text":"1 2 3 4 5 6 7 8 9 10 11 12 const selectionSort = arr => { for ( let i = 0 ; i < arr . length ; i ++ ) { let smallest = i ; for ( let j = i + 1 ; j < arr . length ; j ++ ) { if ( arr [ smallest ] > arr [ j ]) { smallest = j ; } } if ( i !== smallest ) swap ( arr , i , smallest ); } return arr ; };","title":"selectionSort(arr)"},{"location":"JavaScript/04/BinarySearchTree/","text":"1 2 3 4 5 6 7 class Node { constructor ( val ) { this . val = val ; this . left = null ; this . right = null ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class BinarySearchTree { constructor () { this . root = null ; } insert ( val ) { const newNode = new Node ( val ); if ( this . root === null ) { this . root = newNode ; return this ; } let curr = this . root ; while ( true ) { if ( val === curr . val ) return undefined ; if ( val < curr . val ) { if ( curr . left === null ) { curr . left = newNode ; return this ; } curr = curr . left ; } else { if ( curr . right === null ) { curr . right = newNode ; return this ; } curr = curr . right ; } } } find ( val ) { if ( this . root === null ) return false ; let curr = this . root ; let found = false ; while ( curr && ! found ) { if ( val < curr . val ) { curr = curr . left ; } else if ( val > curr . val ) { curr = curr . right ; } else { found = true ; } } if ( ! found ) return undefined ; return curr ; } contains ( val ) { if ( this . root === null ) return false ; let curr = this . root ; let found = false ; while ( curr && ! found ) { if ( val < curr . val ) { curr = curr . left ; } else if ( val > curr . val ) { curr = curr . right ; } else { return true ; } } return false ; } bfs () { let node = this . root ; const ret = []; const queue = [ node ]; while ( queue . length ) { node = queue . shift (); ret . push ( node . val ); if ( node . left ) queue . push ( node . left ); if ( node . right ) queue . push ( node . right ); } return ret ; } dfs () { let node = this . root ; const ret = []; const stack = [ node ]; while ( stack . length ) { node = stack . pop (); ret . push ( node . val ); if ( node . right ) stack . push ( node . right ); if ( node . left ) stack . push ( node . left ); } return ret ; } preOrder () { const ret = []; const traverse = node => { ret . push ( node . val ); if ( node . left ) traverse ( node . left ); if ( node . right ) traverse ( node . right ); }; traverse ( this . root ); return ret ; } postOrder () { const ret = []; const traverse = node => { if ( node . left ) traverse ( node . left ); if ( node . right ) traverse ( node . right ); ret . push ( node . val ); }; traverse ( this . root ); return ret ; } inOrder () { const ret = []; const traverse = node => { if ( node . left ) traverse ( node . left ); ret . push ( node . val ); if ( node . right ) traverse ( node . right ); }; traverse ( this . root ); return ret ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var tree = new BinarySearchTree (); tree . insert ( 10 ); tree . insert ( 6 ); tree . insert ( 3 ); tree . insert ( 8 ); tree . insert ( 15 ); tree . insert ( 20 ); // 10 // 6 15 // 3 8 20 tree . bfs (); // [10, 6, 15, 3, 8, 20] tree . dfs (); // [10, 6, 3, 8, 15, 20] tree . preOrder (); // [10, 6, 3, 8, 15, 20] tree . postOrder (); // [3, 8, 6, 20, 15, 10] tree . inOrder (); // [3, 6, 8, 10, 15, 20]","title":"Binary Search Tree"},{"location":"JavaScript/04/DoublyLinkedList/","text":"1 2 3 4 5 6 7 class Node { constructor ( val ) { this . val = val ; this . next = null ; this . prev = null ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class DoublyLinkedList { constructor () { this . head = null ; this . tail = null ; this . length = 0 ; } push ( val ) { const newNode = new Node ( val ); if ( this . length === 0 ) { this . head = newNode ; this . tail = newNode ; } else { this . tail . next = newNode ; newNode . prev = this . tail ; this . tail = newNode ; } this . length ++ ; return this ; } pop () { if ( ! this . head ) return undefined ; let poppedNode = this . tail ; if ( this . length === 1 ) { this . head = null ; this . tail = null ; } else { this . tail = poppedNode . prev ; this . tail . next = null ; poppedNode . prev = null ; } this . length -- ; return poppedNode ; } shift () { if ( this . length === 0 ) return undefined ; let oldHead = this . head ; if ( this . length === 1 ) { this . head = null ; this . tail = null ; } else { this . head = oldHead . next ; this . head . prev = null ; oldHead . next = null ; } this . length -- ; return oldHead ; } unshift ( val ) { const newNode = new Node ( val ); if ( this . length === 0 ) { this . head = newNode ; this . tail = newNode ; } else { this . head . prev = newNode ; newNode . next = this . head ; this . head = newNode ; } this . length ++ ; return this ; } get ( index ) { if ( index < 0 || index >= this . length ) return null ; let curr = null ; if ( index <= this . length / 2 ) { let count = 0 ; curr = this . head ; while ( count !== index ) { curr = curr . next ; count ++ ; } } else { let count = this . length - 1 ; curr = this . tail ; while ( count !== index ) { curr = curr . prev ; count -- ; } } return curr ; } set ( index , val ) { let foundNode = this . get ( index ); if ( foundNode ) { foundNode . val = val ; return true ; } return false ; } insert ( index , val ) { if ( index < 0 || index > this . length ) return false ; if ( index === 0 ) return this . unshift ( val ); if ( index === this . length ) return [... this , val ]; const newNode = new Node ( val ); let prev = this . get ( index - 1 ); let next = prev . next ; ( prev . next = newNode ), ( newNode . prev = prev ); ( newNode . next = next ), ( next . prev = newNode ); this . length ++ ; return true ; } remove ( index ) { if ( index < 0 || index >= this . length ) return undefined ; if ( index === 0 ) return this . shift (); if ( index === this . length ) return this . pop (); let removedNode = this . get ( index ); removedNode . prev . next = removedNode . next ; removedNode . next . prev = removedNode . prev ; removedNode . next = null ; removedNode . prev = null ; this . length -- ; return removedNode ; } print () { const arr = []; let curr = this . head ; while ( curr ) { arr . push ( curr . val ); curr = curr . next ; } console . log ( arr ); } } 1 2 3 let list = new DoublyLinkedList (); for ( let i = 0 ; i < 5 ; i ++ ) list . push ( i );","title":"Doubly Linked List"},{"location":"JavaScript/04/MaxBinaryHeap/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class MaxBinaryHeap { constructor () { this . arr = []; } insert ( elem ) { this . arr = [... this . arr , elem ]; this . bubbleUp (); } bubbleUp () { let index = this . arr . length - 1 ; const elem = this . arr [ index ]; while ( index > 0 ) { let parentIndex = Math . floor (( index - 1 ) / 2 ); let parent = this . arr [ parentIndex ]; if ( elem <= parent ) break ; this . arr [ parentIndex ] = elem ; this . arr [ index ] = parent ; index = parentIndex ; } } extractMax () { const max = this . arr [ 0 ]; const end = this . arr . pop (); if ( this . arr . length > 0 ) { this . arr [ 0 ] = end ; this . sinkDown (); } return max ; } sinkDown () { let index = 0 ; const { length } = this . arr ; const elem = this . arr [ index ]; while ( true ) { let leftChildIndex = 2 * index + 1 ; let rightChildIndex = 2 * index + 2 ; let leftChild = null ; let rightChild = null ; let swap = null ; if ( leftChildIndex < length ) { leftChild = this . arr [ leftChildIndex ]; if ( leftChild > elem ) { swap = leftChildIndex ; } } if ( rightChildIndex < length ) { rightChild = this . arr [ rightChildIndex ]; if ( ( swap === null && rightChild > elem ) || ( swap !== null && rightChild > leftChild ) ) { swap = rightChildIndex ; } } if ( swap === null ) break ; this . arr [ index ] = this . arr [ swap ]; this . arr [ swap ] = elem ; index = swap ; } } } 1 2 3 4 5 6 7 8 9 10 11 12 let heap = new MaxBinaryHeap (); heap . insert ( 41 ); heap . insert ( 39 ); heap . insert ( 33 ); heap . insert ( 18 ); heap . insert ( 27 ); heap . insert ( 12 ); heap . insert ( 55 ); // [55, 39, 41, 18, 27, 12, 33] heap . extractMax (); // [41, 39, 33, 18, 27, 12]","title":"Max Binary Heap"},{"location":"JavaScript/04/MaxPriorityQueue/","text":"1 2 3 4 5 6 class Node { constructor ( val , priority ) { this . val = val ; this . priority = priority ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class MaxPriorityQueue { constructor () { this . arr = []; } enqueue ( val , priority ) { const newNode = new Node ( val , priority ); this . arr = [... this . arr , newNode ]; this . bubbleUp (); } bubbleUp () { let index = this . arr . length - 1 ; const elem = this . arr [ index ]; while ( index > 0 ) { let parentIndex = Math . floor (( index - 1 ) / 2 ); let parent = this . arr [ parentIndex ]; if ( elem . priority <= parent . priority ) break ; this . arr [ parentIndex ] = elem ; this . arr [ index ] = parent ; index = parentIndex ; } } dequeue () { const max = this . arr [ 0 ]; const end = this . arr . pop (); if ( this . arr . length > 0 ) { this . arr [ 0 ] = end ; this . sinkDown (); } return max ; } sinkDown () { let index = 0 ; const { length } = this . arr ; const elem = this . arr [ index ]; while ( true ) { let leftChildIndex = 2 * index + 1 ; let rightChildIndex = 2 * index + 2 ; let leftChild = null ; let rightChild = null ; let swap = null ; if ( leftChildIndex < length ) { leftChild = this . arr [ leftChildIndex ]; if ( leftChild . priority > elem . priority ) { swap = leftChildIndex ; } } if ( rightChildIndex < length ) { rightChild = this . arr [ rightChildIndex ]; if ( ( swap === null && rightChild . priority > elem . priority ) || ( swap !== null && rightChild . priority > leftChild . priority ) ) { swap = rightChildIndex ; } } if ( swap === null ) break ; this . arr [ index ] = this . arr [ swap ]; this . arr [ swap ] = elem ; index = swap ; } } } 1 2 3 4 5 let queue = new MaxPriorityQueue (); queue . enqueue ( 'Drink water' , 1 ); queue . enqueue ( 'Sleep' , 5 ); queue . enqueue ( 'Eat' , 2 );","title":"Max Priority Queue"},{"location":"JavaScript/04/SinglyLinkedList/","text":"1 2 3 4 5 6 class Node { constructor ( val ) { this . val = val ; this . next = null ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 class SinglyLinkedList { constructor () { this . head = null ; this . tail = null ; this . length = 0 ; } push ( val ) { const newNode = new Node ( val ); if ( ! this . head ) { this . head = newNode ; this . tail = this . head ; } else { this . tail . next = newNode ; this . tail = newNode ; } this . length ++ ; return this ; } pop () { if ( ! this . head ) return undefined ; let poppedNode = this . head ; let newTail = poppedNode ; if ( this . length === 1 ) { this . head = null ; this . tail = null ; } else { while ( poppedNode . next ) { newTail = poppedNode ; poppedNode = poppedNode . next ; } this . tail = newTail ; this . tail . next = null ; } this . length -- ; return poppedNode ; } shift () { if ( this . length === 0 ) return undefined ; let oldHead = this . head ; if ( this . length === 1 ) { this . head = null ; this . tail = null ; } else { this . head = oldHead . next ; oldHead . next = null ; } this . length -- ; return oldHead ; } unshift ( val ) { const newNode = new Node ( val ); if ( this . length === 0 ) { this . head = newNode ; this . tail = newNode ; } else { newNode . next = this . head ; this . head = newNode ; } this . length ++ ; return this ; } get ( index ) { if ( index < 0 || index >= this . length ) return null ; let count = 0 ; let curr = this . head ; while ( count !== index ) { curr = curr . next ; count ++ ; } return curr ; } set ( index , val ) { let foundNode = this . get ( index ); if ( foundNode ) { foundNode . val = val ; return true ; } return false ; } insert ( index , val ) { if ( index < 0 || index > this . length ) return false ; if ( index === 0 ) return this . unshift ( val ); if ( index === this . length ) return [... this , val ]; const newNode = new Node ( val ); let prev = this . get ( index - 1 ); let next = prev . next ; prev . next = newNode ; newNode . next = next ; this . length ++ ; return true ; } remove ( index ) { if ( index < 0 || index >= this . length ) return undefined ; if ( index === 0 ) return this . shift (); if ( index === this . length - 1 ) return this . pop (); let prev = this . get ( index - 1 ); let removedNode = prev . next ; prev . next = removedNode . next ; removedNode . next = null ; this . length -- ; return removedNode ; } reverse () { let node = this . head ; this . head = this . tail ; this . tail = node ; let oldNext ; let prev = null ; for ( let i = 0 ; i < this . length ; i ++ ) { oldNext = node . next ; node . next = prev ; prev = node ; node = oldNext ; } return this ; } print () { const arr = []; let curr = this . head ; while ( curr ) { arr . push ( curr . val ); curr = curr . next ; } console . log ( arr ); } } 1 2 3 let list = new SinglyLinkedList (); for ( let i = 0 ; i < 5 ; i ++ ) list . push ( i );","title":"Singly Linked List"},{"location":"JavaScript/05/Dijkstra/","text":"1 2 3 4 5 6 class Node { constructor ( val , priority ) { this . val = val ; this . priority = priority ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class MinPriorityQueue { constructor () { this . arr = []; } enqueue ( val , priority ) { const newNode = new Node ( val , priority ); this . arr = [... this . arr , newNode ]; this . bubbleUp (); } bubbleUp () { let index = this . arr . length - 1 ; const elem = this . arr [ index ]; while ( index > 0 ) { let parentIndex = Math . floor (( index - 1 ) / 2 ); let parent = this . arr [ parentIndex ]; if ( elem . priority >= parent . priority ) break ; this . arr [ parentIndex ] = elem ; this . arr [ index ] = parent ; index = parentIndex ; } } dequeue () { const min = this . arr [ 0 ]; const end = this . arr . pop (); if ( this . arr . length > 0 ) { this . arr [ 0 ] = end ; this . sinkDown (); } return min ; } sinkDown () { let index = 0 ; const { length } = this . arr ; const elem = this . arr [ index ]; while ( true ) { let leftChildIndex = 2 * index + 1 ; let rightChildIndex = 2 * index + 2 ; let leftChild = null ; let rightChild = null ; let swap = null ; if ( leftChildIndex < length ) { leftChild = this . arr [ leftChildIndex ]; if ( leftChild . priority < elem . priority ) { swap = leftChildIndex ; } } if ( rightChildIndex < length ) { rightChild = this . arr [ rightChildIndex ]; if ( ( swap === null && rightChild . priority < elem . priority ) || ( swap !== null && rightChild . priority < leftChild . priority ) ) { swap = rightChildIndex ; } } if ( swap === null ) break ; this . arr [ index ] = this . arr [ swap ]; this . arr [ swap ] = elem ; index = swap ; } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class WeightedGraph { constructor () { this . adjList = {}; } addVertex ( vertex ) { if ( ! this . adjList [ vertex ]) this . adjList [ vertex ] = []; } addEdge ( v1 , v2 , weight ) { this . adjList [ v1 ] = [... this . adjList [ v1 ], { node : v2 , weight }]; this . adjList [ v2 ] = [... this . adjList [ v2 ], { node : v1 , weight }]; } Dijkstra ( start , end ) { const nodes = new MinPriorityQueue (); const dist = {}; const prev = {}; let path = []; let smallest ; for ( let vertex in this . adjList ) { if ( vertex === start ) { dist [ vertex ] = 0 ; nodes . enqueue ( vertex , 0 ); } else { dist [ vertex ] = Infinity ; nodes . enqueue ( vertex , Infinity ); } prev [ vertex ] = null ; } while ( nodes . arr . length ) { smallest = nodes . dequeue (). val ; if ( smallest === end ) { while ( prev [ smallest ]) { path . push ( smallest ); smallest = prev [ smallest ]; } break ; } if ( smallest || dist [ smallest ] !== Infinity ) { for ( let neighbor in this . adjList [ smallest ]) { let nextNode = this . adjList [ smallest ][ neighbor ]; let candidate = dist [ smallest ] + nextNode . weight ; let nextNeighbor = nextNode . node ; if ( candidate < dist [ nextNeighbor ]) { dist [ nextNeighbor ] = candidate ; prev [ nextNeighbor ] = smallest ; nodes . enqueue ( nextNeighbor , candidate ); } } } } return path . concat ( smallest ). reverse (); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 let g = new WeightedGraph (); g . addVertex ( 'A' ); g . addVertex ( 'B' ); g . addVertex ( 'C' ); g . addVertex ( 'D' ); g . addVertex ( 'E' ); g . addVertex ( 'F' ); g . addEdge ( 'A' , 'B' , 4 ); g . addEdge ( 'A' , 'C' , 2 ); g . addEdge ( 'B' , 'E' , 3 ); g . addEdge ( 'C' , 'D' , 2 ); g . addEdge ( 'C' , 'F' , 4 ); g . addEdge ( 'D' , 'E' , 3 ); g . addEdge ( 'D' , 'F' , 1 ); g . addEdge ( 'E' , 'F' , 1 ); g . Dijkstra ( 'A' , 'E' ); // ['A', 'C', 'D', 'F', 'E']","title":"Dijkstra Algorithm"},{"location":"JavaScript/05/Graph/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class Graph { constructor () { this . adjList = {}; } addVertex ( vertex ) { if ( ! this . adjList [ vertex ]) this . adjList [ vertex ] = []; } addEdge ( v1 , v2 ) { this . adjList [ v1 ] = [... this . adjList [ v1 ], v2 ]; this . adjList [ v2 ] = [... this . adjList [ v2 ], v1 ]; } removeEdge ( v1 , v2 ) { this . adjList [ v1 ] = this . adjList [ v1 ]. filter ( v => v !== v2 ); this . adjList [ v2 ] = this . adjList [ v2 ]. filter ( v => v !== v1 ); } removeVertex ( vertex ) { while ( this . adjList [ vertex ]. length ) { const adjVertex = this . adjList [ vertex ]. pop (); this . removeEdge ( vertex , adjVertex ); } delete this . adjList [ vertex ]; } dfsRecursive ( start ) { const ret = []; const visited = {}; const adjList = this . adjList ; ( function dfs ( vertex ) { if ( ! vertex ) return null ; visited [ vertex ] = true ; ret . push ( vertex ); adjList [ vertex ]. forEach ( neighbor => { if ( ! visited [ neighbor ]) { return dfs ( neighbor ); } }); })( start ); return ret ; } dfsIterative ( start ) { const ret = []; const visited = {}; const stack = [ start ]; let currVertex ; visited [ start ] = true ; while ( stack . length ) { currVertex = stack . pop (); ret . push ( currVertex ); this . adjList [ currVertex ]. forEach ( neighbor => { if ( ! visited [ neighbor ]) { visited [ neighbor ] = true ; stack . push ( neighbor ); } }); } return ret ; } bfs ( start ) { const ret = []; const visited = {}; const queue = [ start ]; let currVertex ; visited [ start ] = true ; while ( queue . length ) { currVertex = queue . shift (); ret . push ( currVertex ); this . adjList [ currVertex ]. forEach ( neighbor => { if ( ! visited [ neighbor ]) { visited [ neighbor ] = true ; queue . push ( neighbor ); } }); } return ret ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 let g = new Graph (); g . addVertex ( 'A' ); g . addVertex ( 'B' ); g . addVertex ( 'C' ); g . addVertex ( 'D' ); g . addVertex ( 'E' ); g . addVertex ( 'F' ); g . addEdge ( 'A' , 'B' ); g . addEdge ( 'A' , 'C' ); g . addEdge ( 'B' , 'D' ); g . addEdge ( 'C' , 'E' ); g . addEdge ( 'D' , 'E' ); g . addEdge ( 'D' , 'F' ); g . addEdge ( 'E' , 'F' ); // A // / \\ // B C // | | // D - E // \\ / // F g . dfsRecursive ( 'A' ); // ['A', 'B', 'D', 'E', 'C', 'F'] g . dfsIterative ( 'A' ); // ['A', 'C', 'E', 'F', 'D', 'B'] g . bfs ( 'A' ); // ['A', 'B', 'C', 'D', 'E', 'F']","title":"Graph"}]}